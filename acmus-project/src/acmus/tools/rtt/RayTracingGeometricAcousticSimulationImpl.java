package acmus.tools.rtt;

import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;
/*
 * unused imports ...
 * import java.util.HashMap;
 * import java.util.Iterator;
 */

import org.eclipse.swt.widgets.ProgressBar;

import acmus.tools.structures.AcousticSource;
import acmus.tools.structures.EnergeticSimulatedImpulseResponse;
import acmus.tools.structures.NormalSector;
import acmus.tools.structures.SimulatedImpulseResponse;
import acmus.tools.structures.Vector;
/* 
 * unused imports ...
 * import acmus.tools.structures.EnergeticSimulatedImpulseResponseArray;
 */

public class RayTracingGeometricAcousticSimulationImpl implements GeometricAcousticSimulation {

	private List<NormalSector> sectors;
	private int numberOfRays;
	private AcousticSource soundSource;
	private Vector sphericalReceptorCenter;
	double sphericalReceptorRadius;
	double soundSpeed;
	double airAbsorptionCoeficient;
	double k;
	private SimulatedImpulseResponse simulatedImpulseResponse;
	private float histogramInterval;
	

	public RayTracingGeometricAcousticSimulationImpl(List<NormalSector> sectors,
			AcousticSource soundSource, int numberOfRays, Vector sphericalReceptorCenter,
			double sphericalReceptorRadius, double soundSpeed,
			double airAbsortionCoeficient, int k) {
		this.sectors = sectors;
		this.numberOfRays = numberOfRays;
		this.soundSource = soundSource;
		this.sphericalReceptorCenter = sphericalReceptorCenter;
		this.sphericalReceptorRadius = sphericalReceptorRadius;
		this.soundSpeed = soundSpeed;
		this.airAbsorptionCoeficient = airAbsortionCoeficient;
		this.k = k;
		histogramInterval = 0.00001f;
		
		//interval calculated according to Gomes2008, see Mario h.c.t. Masters dissertation
		simulatedImpulseResponse = new EnergeticSimulatedImpulseResponse(histogramInterval);
	}

	public void simulate(final ProgressBar progressBar) {
		
		Vector tempRayPosition = soundSource.getCenter();
		Vector rayPosition = null;
		Vector rayDirection;
		Vector normalReflectionSector = null;
		double e;
		float lMin = 0.0f;
		float dMin = 0.0f;
		double alpha = 0.0;
		double rayLength;

		// ray tracing of rays generated by sound source
		int i = 0;
		nextRay:
		for (; i < numberOfRays; i++) {
			if (i % Math.max(1,(numberOfRays/100)) == 0) {
				progressBar.setSelection((int) (100.0*i/numberOfRays));
			}
			tempRayPosition = soundSource.getCenter();
			rayDirection = soundSource.generate();
			e = 1.0;
			rayLength = 0;
			
			do {
				rayPosition = tempRayPosition;
				lMin = Float.MAX_VALUE;

				/**
				 *  verify the interception section
				 */
				for (NormalSector s : sectors) {
					if (rayDirection.dotProduct(s.normalVector) >= 0) {
						continue;
					} else {
						float d = s.normalVector.dotProduct(rayPosition.sub(s.iPoint));
						float l = -1 * d / (rayDirection.dotProduct(s.normalVector));

						// put the point in polygon test
						if (l <= lMin) {
							lMin = l;
							dMin = d;
							alpha = s.absorptionCoeficient;
							normalReflectionSector = s.normalVector;
						}
					}
				}// end sectors
				
				tempRayPosition = rayPosition.add(rayDirection.times(lMin)); //interception point 
				double eTemp = e * (1 - alpha) * Math.pow(Math.E, -1 * airAbsorptionCoeficient * lMin);

				/*
				 * ray receptor interception test
				 */
				{
					Vector oc = sphericalReceptorCenter.sub(rayPosition);
					double l2oc = oc.dotProduct(oc);
					double tca = oc.dotProduct(rayDirection);

					if (tca >= 0) { 
						double t2hc = sphericalReceptorRadius * sphericalReceptorRadius - l2oc + tca * tca;

						if (t2hc > 0) { // ray V intercepts spherical receptor
							double lThisReflection = tca - Math.sqrt(t2hc);
							double distance = rayLength + lThisReflection;
							double time = distance / soundSpeed;
							double eSphere = e * Math.pow(Math.E, -1 * airAbsorptionCoeficient * lThisReflection) * tca / sphericalReceptorRadius;

							simulatedImpulseResponse.addValue((float)time, (float)eSphere);
							
							continue nextRay;
						}
					}
				}
				
				rayLength += lMin;
				e = eTemp;
				rayDirection = normalReflectionSector.times(2 * dMin).add(tempRayPosition.sub(rayPosition));
				rayDirection = rayDirection.normalize(); //new ray direction
				
			} while (e > (1 / k )); //ray energy threshold
		}// ends tracing of rays
	}

	public SimulatedImpulseResponse getSimulatedImpulseResponse() {
		return simulatedImpulseResponse;
	}

	public void lista() throws IOException {
		FileWriter fw = new FileWriter("/tmp/hist.txt");
		StringBuilder sx = new StringBuilder(2000);
		StringBuilder sy = new StringBuilder(2000);
		StringBuilder ss = new StringBuilder(2000);

		for (Map.Entry<Float, Float> e : getSimulatedImpulseResponse().getEnergeticImpulseResponse().entrySet()) {
			sx.append(e.getKey());
			sx.append(" ");
			sy.append(e.getValue());
			sy.append(" ");

			ss.append(e.getKey());
			ss.append("\t");
			ss.append(e.getValue());
			ss.append("\n");

		}
		// fw.write("x=[" + sx.toString() + "0]; y=[" + sy.toString() + "0]");
		fw.write(ss.toString());
		fw.close();
	}
}
